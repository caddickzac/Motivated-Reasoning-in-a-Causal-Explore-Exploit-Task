###################################################################
# Changing a Policy and Holding others Stable for Periods of Time #
###################################################################

# import libraries 
library("tidyverse")
library("ddpcr") # for "merge_dfs_overwrite_col" function

# Import data
Changing_a_Policy_and_Holding_others_Stable <- tibble(read.csv(
  "Study3_Changing_a_Policy_and_Holding_others_Stable.csv"))

# preview data
head(Changing_a_Policy_and_Holding_others_Stable)

# data dictionary:
##  "Participant" = participant number
##  "Function_Exposure" = refers to function exposure condition assignment (1=yes, 0=no)
##  "Trial" = learning trial number (ranges: 11-151). Participants could only change input on trials 11-150 (1-10 were for learning purposes, and trial 151 was for final assessments of policies)
##  "F1_Input" = denotes on (1) / off (0) inputs for Function 1 (see payoff function figure for details)
##  "F2_Input" = denotes on (1) / off (0) inputs for Function 2 (see payoff function figure for details)
##  "F3_Input" = denotes on (1) / off (0) inputs for Function 3 (see payoff function figure for details)
##  "F4_Input" = denotes on (1) / off (0) inputs for Function 4 (see payoff function figure for details)
##  "F5_Input" = denotes on (1) / off (0) inputs for Function 5 (see payoff function figure for details)
##  "F6_Input" = denotes on (1) / off (0) inputs for Function 6 (see payoff function figure for details)
##  "F1_Pref_Policy_is_Optimal" = denotes if participants preferred policy is the optimal policy for Function 1 (1=yes, -1=no, -88=neutral policy/no opportunity for preference-congruence)
##  "F2_Pref_Policy_is_Optimal" = denotes if participants preferred policy is the optimal policy for Function 2 (1=yes, -1=no, -88=neutral policy/no opportunity for preference-congruence)
##  "F3_Pref_Policy_is_Optimal" = denotes if participants preferred policy is the optimal policy for Function 3 (1=yes, -1=no, -88=neutral policy/no opportunity for preference-congruence)
##  "F4_Pref_Policy_is_Optimal" = denotes if participants preferred policy is the optimal policy for Function 4 (1=yes, -1=no, -88=neutral policy/no opportunity for preference-congruence)
##  "F1_Pref_Policy" = Notes whether or not Function 1 was set to a preferred policy (coded as 1), non preferred (coded as 0), or if neutral policy (-88)
##  "F2_Pref_Policy" = Notes whether or not Function 2 was set to a preferred policy (coded as 1), non preferred (coded as 0), or if neutral policy (-88)
##  "F3_Pref_Policy" = Notes whether or not Function 3 was set to a preferred policy (coded as 1), non preferred (coded as 0), or if neutral policy (-88)
##  "F4_Pref_Policy" = Notes whether or not Function 4 was set to a preferred policy (coded as 1), non preferred (coded as 0), or if neutral policy (-88)
##  "F5_Pref_Policy" = Notes whether or not Function 5 was set to a preferred policy (coded as 1), non preferred (coded as 0), or if neutral policy (-88)
##  "F6_Pref_Policy" = Notes whether or not Function 6 was set to a preferred policy (coded as 1), non preferred (coded as 0), or if neutral policy (-88)
##  "F1_Policy_Change" = denotes if a policy change was made on a given trial for Function 1 (1=change, 0=no change)
##  "F2_Policy_Change" = denotes if a policy change was made on a given trial for Function 2 (1=change, 0=no change)
##  "F3_Policy_Change" = denotes if a policy change was made on a given trial for Function 3 (1=change, 0=no change)
##  "F4_Policy_Change" = denotes if a policy change was made on a given trial for Function 4 (1=change, 0=no change)
##  "F5_Policy_Change" = denotes if a policy change was made on a given trial for Function 5 (1=change, 0=no change)
##  "F6_Policy_Change" = denotes if a policy change was made on a given trial for Function 6 (1=change, 0=no change)
##  "Total_Policy_Changes" = sum of policy changes for Functions 1-6 on a given trial 
### for "Policy_Test_Type" variables below:
#### these variables categorize type of policy change (if one occurred, "NA" otherwise). 
#### the numbers 1-7 denote the number of Trials System was Held Constant after a change. 
#### the label "8+" groups all tests that were held constant over 7 trials.
#### the label "C" represents confounded (two or more) changes. 
#### the label "NT" is placed on Trial 150 (the last possible trial to make a change) if a function was Never Tested by a participant. 
##  "F1_Policy_Test_Type" = see above details
##  "F2_Policy_Test_Type" = see above details
##  "F3_Policy_Test_Type" = see above details
##  "F4_Policy_Test_Type" = see above details
##  "F5_Policy_Test_Type" = see above details
##  "F6_Policy_Test_Type" = see above details

#--------------------------------------------------------------------------------------------------------------------------

###########################################################################
# Step 1. Count instances of each testing category type for each Function #
###########################################################################

# Function 1
F1_Testing_data <- 
  aggregate(Changing_a_Policy_and_Holding_others_Stable$F1_Policy_Test_Type, by=list(Changing_a_Policy_and_Holding_others_Stable$Participant,
                                                                                     Changing_a_Policy_and_Holding_others_Stable$F1_Policy_Test_Type), length) %>% 
  rename("Participant"=Group.1,
         "Testing_Category"=Group.2,
         "Count"=x) %>% 
  arrange(Participant, Testing_Category)
F1_Testing_data$Function <- rep("F1", length(F1_Testing_data$Participant))

# Function 2
F2_Testing_data <- 
  aggregate(Changing_a_Policy_and_Holding_others_Stable$F2_Policy_Test_Type, by=list(Changing_a_Policy_and_Holding_others_Stable$Participant,
                                                                                     Changing_a_Policy_and_Holding_others_Stable$F2_Policy_Test_Type), length) %>% 
  rename("Participant"=Group.1,
         "Testing_Category"=Group.2,
         "Count"=x) %>% 
  arrange(Participant, Testing_Category)
F2_Testing_data$Function <- rep("F2", length(F2_Testing_data$Participant))

# Function 3
F3_Testing_data <- 
  aggregate(Changing_a_Policy_and_Holding_others_Stable$F3_Policy_Test_Type, by=list(Changing_a_Policy_and_Holding_others_Stable$Participant,
                                                                                     Changing_a_Policy_and_Holding_others_Stable$F3_Policy_Test_Type), length) %>% 
  rename("Participant"=Group.1,
         "Testing_Category"=Group.2,
         "Count"=x) %>% 
  arrange(Participant, Testing_Category)
F3_Testing_data$Function <- rep("F3", length(F3_Testing_data$Participant))

# Function 4
F4_Testing_data <- 
  aggregate(Changing_a_Policy_and_Holding_others_Stable$F4_Policy_Test_Type, by=list(Changing_a_Policy_and_Holding_others_Stable$Participant,
                                                                                     Changing_a_Policy_and_Holding_others_Stable$F4_Policy_Test_Type), length) %>% 
  rename("Participant"=Group.1,
         "Testing_Category"=Group.2,
         "Count"=x) %>% 
  arrange(Participant, Testing_Category)
F4_Testing_data$Function <- rep("F4", length(F4_Testing_data$Participant))

# Function 5
F5_Testing_data <- 
  aggregate(Changing_a_Policy_and_Holding_others_Stable$F5_Policy_Test_Type, by=list(Changing_a_Policy_and_Holding_others_Stable$Participant,
                                                                                     Changing_a_Policy_and_Holding_others_Stable$F5_Policy_Test_Type), length) %>% 
  rename("Participant"=Group.1,
         "Testing_Category"=Group.2,
         "Count"=x) %>% 
  arrange(Participant, Testing_Category)
F5_Testing_data$Function <- rep("F5", length(F5_Testing_data$Participant))

# Function 6
F6_Testing_data <- 
  aggregate(Changing_a_Policy_and_Holding_others_Stable$F6_Policy_Test_Type, by=list(Changing_a_Policy_and_Holding_others_Stable$Participant,
                                                                                     Changing_a_Policy_and_Holding_others_Stable$F6_Policy_Test_Type), length) %>% 
  rename("Participant"=Group.1,
         "Testing_Category"=Group.2,
         "Count"=x) %>% 
  arrange(Participant, Testing_Category)
F6_Testing_data$Function <- rep("F6", length(F6_Testing_data$Participant))

#--------------------------------------------------------------------------------------------------------------------------

###########################################################################################################
# Step 2: Organize data to show all categories (even if participant had no instances of a given category) #
###########################################################################################################

# Create empty data frame to serve as template for participant data
Testing_Category <- c(as.character(seq(1:7)), "8+", "C", "NT") # vector of testing categories
Count <- rep(0, length(Testing_Category)) # empty values
spree_shell_table <- tibble(Testing_Category, Count) # tibble it / create dataframe

# this function maps Participant data onto a large table (that a participant likely only has a portion of the data for--the rest are zeroes)
spree_Participant_table_creator <- function(testing_dataframe){
  Participant_list <- unique(testing_dataframe$Participant)
  Testing_Category <- c(as.character(seq(1:7)), "8+", "C", "NT") # vector of testing categories
  # empty containers
  output_Participants <- c()
  output_tc <- c()
  output_count <- c()
  for(i in 1:length(Participant_list)){
    # empty matrix to fill
    Count <- rep(0, length(Testing_Category)) # zeroes
    spree_shell_table <- tibble(Testing_Category, Count) # tibble it
    # grab current Participants data
    j=Participant_list[i]
    Participant_data_step_1 <- testing_dataframe %>%  filter(Participant==j)
    Participant_data <- merge_dfs_overwrite_col(spree_shell_table, Participant_data_step_1, "Count", "Testing_Category") 
    # output
    output_Participants <- append(output_Participants, rep(j, length(Count)), after=length(output_Participants))
    output_tc <- append(output_tc, Testing_Category, after=length(output_tc))
    output_count <- append(output_count, Participant_data$Count, after=length(output_count))
  }
  stacked_data <- tibble(output_Participants, output_tc, output_count) %>% 
    rename("Participant"=output_Participants,
           "Testing_Category"=output_tc,
           "Count"=output_count)
  return(stacked_data)
}

# run above function on the testing data for each function
F1_testing_output <- spree_Participant_table_creator(F1_Testing_data)
F2_testing_output <- spree_Participant_table_creator(F2_Testing_data)
F3_testing_output <- spree_Participant_table_creator(F3_Testing_data)
F4_testing_output <- spree_Participant_table_creator(F4_Testing_data)
F5_testing_output <- spree_Participant_table_creator(F5_Testing_data)
F6_testing_output <- spree_Participant_table_creator(F6_Testing_data)

# Add function designation
F1_testing_output$Function <- rep("F1", length(F1_testing_output$Participant))
F2_testing_output$Function <- rep("F2", length(F2_testing_output$Participant))
F3_testing_output$Function <- rep("F3", length(F3_testing_output$Participant))
F4_testing_output$Function <- rep("F4", length(F4_testing_output$Participant))
F5_testing_output$Function <- rep("F5", length(F5_testing_output$Participant))
F6_testing_output$Function <- rep("F6", length(F6_testing_output$Participant))

#--------------------------------------------------------------------------------------------------------------------------

#####################################################################
# Step 3: Create long format version of testing category count data #
#####################################################################

Participant_Stacked <- c(F1_testing_output$Participant, F2_testing_output$Participant, F3_testing_output$Participant,
                         F4_testing_output$Participant, F5_testing_output$Participant, F6_testing_output$Participant)
Testing_Category_Stacked <- c(F1_testing_output$Testing_Category, F2_testing_output$Testing_Category, F3_testing_output$Testing_Category,
                              F4_testing_output$Testing_Category, F5_testing_output$Testing_Category, F6_testing_output$Testing_Category)
Count_Stacked <- c(F1_testing_output$Count, F2_testing_output$Count, F3_testing_output$Count,
                   F4_testing_output$Count, F5_testing_output$Count, F6_testing_output$Count)
Function_Stacked <- c(F1_testing_output$Function, F2_testing_output$Function, F3_testing_output$Function,
                      F4_testing_output$Function, F5_testing_output$Function, F6_testing_output$Function)

Testing_long_form <- tibble(Participant_Stacked, Function_Stacked, Testing_Category_Stacked, Count_Stacked)
names(Testing_long_form) <- c("Participant", "Function", "Testing_Category", "Count")

# label functions by ambiguity type
Testing_long_form$Ambiguity <- ifelse(Testing_long_form$Function=="F1", "Low",
                                      ifelse(Testing_long_form$Function=="F2", "Low",
                                             ifelse(Testing_long_form$Function=="F3", "High",
                                                    ifelse(Testing_long_form$Function=="F4", "High",
                                                           ifelse(Testing_long_form$Function=="F5", "No_Effect",
                                                                  ifelse(Testing_long_form$Function=="F6", "No_Effect", ""))))))

#--------------------------------------------------------------------------------------------------------------------------

#######################################################################################
# Step 4: Aggregate data from individual functions to being grouped by ambiguity type # 
#######################################################################################

Testing_long_form_averaged <- tibble(aggregate(Testing_long_form$Count,
                                               by=list(Testing_long_form$Participant,
                                                       Testing_long_form$Ambiguity,
                                                       Testing_long_form$Testing_Category),
                                               mean) %>% 
                                       rename("Participant"=Group.1,
                                              "Ambiguity"=Group.2,
                                              "Testing_Category"=Group.3,
                                              "Avg_Count"=x) %>% 
                                       arrange(Participant, Ambiguity, Testing_Category))


# separate data into sub-dataframes for each ambiguity type
Testing_long_form_averaged_LOW <- Testing_long_form_averaged %>% 
  filter(Ambiguity=="Low")
Testing_long_form_averaged_HIGH <- Testing_long_form_averaged %>% 
  filter(Ambiguity=="High")
Testing_long_form_averaged_NO_EFFECT <- Testing_long_form_averaged %>% 
  filter(Ambiguity=="No_Effect")

#--------------------------------------------------------------------------------------------------------------------------

##################################################################
# Step 5: Aggregate data to group level (from participant level) #
##################################################################

# Low Ambiguity Functions
Testing_long_form_averaged_LOW_output <- aggregate(Testing_long_form_averaged_LOW$Avg_Count, 
                                                   by=list(Testing_long_form_averaged_LOW$Testing_Category),
                                                   mean) %>% 
  rename("Testing_Category"=Group.1,
         "Avg_Count"=x)
Testing_long_form_averaged_LOW_output$Avg_Count <- round(Testing_long_form_averaged_LOW_output$Avg_Count,2)
Testing_long_form_averaged_LOW_output 

# High Ambiguity Functions
Testing_long_form_averaged_HIGH_output <- aggregate(Testing_long_form_averaged_HIGH$Avg_Count, 
                                                    by=list(Testing_long_form_averaged_HIGH$Testing_Category),
                                                    mean) %>% 
  rename("Testing_Category"=Group.1,
         "Avg_Count"=x)
Testing_long_form_averaged_HIGH_output$Avg_Count <- round(Testing_long_form_averaged_HIGH_output$Avg_Count,2)
Testing_long_form_averaged_HIGH_output

# No Effect Functions
Testing_long_form_averaged_NO_EFFECT_output <- aggregate(Testing_long_form_averaged_NO_EFFECT$Avg_Count, 
                                                         by=list(Testing_long_form_averaged_NO_EFFECT$Testing_Category),
                                                         mean) %>% 
  rename("Testing_Category"=Group.1,
         "Avg_Count"=x)
Testing_long_form_averaged_NO_EFFECT_output$Avg_Count <- round(Testing_long_form_averaged_NO_EFFECT_output$Avg_Count,2)
Testing_long_form_averaged_NO_EFFECT_output
